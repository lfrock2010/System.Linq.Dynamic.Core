<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AmbiguousConstructorInvocation" xml:space="preserve">
    <value>'{0}' コンストラクターのあいまいな呼び出し</value>
  </data>
  <data name="AmbiguousIndexerInvocation" xml:space="preserve">
    <value>タイプ '{0}' のインデクサーのあいまいな呼び出しです</value>
  </data>
  <data name="AmbiguousMethodInvocation" xml:space="preserve">
    <value>型 '{1}' のメソッド '{0}' のあいまいな呼び出しです</value>
  </data>
  <data name="ArgsIncompatibleWithLambda" xml:space="preserve">
    <value>ラムダ式と互換性のない引数リスト</value>
  </data>
  <data name="BothTypesConvertToOther" xml:space="preserve">
    <value>両方の型 '{0}' と '{1}' への変換、他の</value>
  </data>
  <data name="CannotConvertValue" xml:space="preserve">
    <value>型 '{0}' の値は型 '{1}' に変換できません</value>
  </data>
  <data name="CannotIndexMultiDimArray" xml:space="preserve">
    <value>多次元配列のインデックス作成はサポートされていません</value>
  </data>
  <data name="CloseBracketOrCommaExpected" xml:space="preserve">
    <value>'] 'または'、' 予想</value>
  </data>
  <data name="CloseParenOrCommaExpected" xml:space="preserve">
    <value>') 'または'、' 予想</value>
  </data>
  <data name="CloseParenOrOperatorExpected" xml:space="preserve">
    <value>')' または演算子を予想</value>
  </data>
  <data name="ColonExpected" xml:space="preserve">
    <value>':' 予想</value>
  </data>
  <data name="DigitExpected" xml:space="preserve">
    <value>期待される数字</value>
  </data>
  <data name="DotOrOpenParenExpected" xml:space="preserve">
    <value>'です' または '(' expected。</value>
  </data>
  <data name="DuplicateIdentifier" xml:space="preserve">
    <value>識別子 '{0}' が複数回定義されました</value>
  </data>
  <data name="ExpressionExpected" xml:space="preserve">
    <value>式が必要です。</value>
  </data>
  <data name="ExpressionTypeMismatch" xml:space="preserve">
    <value>型 '{0}' が予想の表現</value>
  </data>
  <data name="FirstExprMustBeBool" xml:space="preserve">
    <value>最初の式は、'ブール' 型である必要があります。</value>
  </data>
  <data name="IdentifierExpected" xml:space="preserve">
    <value>識別子が必要</value>
  </data>
  <data name="IdentifierImplementingInterfaceExpected" xml:space="preserve">
    <value>実装インターフェイス '{0}' が予想される識別子</value>
  </data>
  <data name="IifRequiresThreeArgs" xml:space="preserve">
    <value>'Iif' 関数には 3 つの引数が必要です。</value>
  </data>
  <data name="IncompatibleOperand" xml:space="preserve">
    <value>演算子 '{0}' のオペランドと互換性のない型 '{1}'</value>
  </data>
  <data name="IncompatibleOperands" xml:space="preserve">
    <value>演算子 '{0}' '{1}' と '{2}' オペランドの型と互換性がありません。</value>
  </data>
  <data name="InvalidCharacter" xml:space="preserve">
    <value>構文エラー ' {0} '</value>
  </data>
  <data name="InvalidCharacterLiteral" xml:space="preserve">
    <value>文字リテラルは 1 文字を含める必要があります。</value>
  </data>
  <data name="InvalidIndex" xml:space="preserve">
    <value>配列のインデックスは整数式をする必要があります。</value>
  </data>
  <data name="InvalidIntegerLiteral" xml:space="preserve">
    <value>無効な整数リテラル '{0}'</value>
  </data>
  <data name="InvalidRealLiteral" xml:space="preserve">
    <value>無効な実際のリテラル '{0}'</value>
  </data>
  <data name="MethodIsVoid" xml:space="preserve">
    <value>型 '{1}' のメソッド '{0}' は値を返しません</value>
  </data>
  <data name="MethodsAreInaccessible" xml:space="preserve">
    <value>型 '{0}' のメソッドにはアクセスできません。</value>
  </data>
  <data name="MissingAsClause" xml:space="preserve">
    <value>式に 'as' 句がありません。</value>
  </data>
  <data name="NeitherTypeConvertsToOther" xml:space="preserve">
    <value>どちらも、他の種類 '{0}' と '{1}' 変換の</value>
  </data>
  <data name="NoApplicableAggregate" xml:space="preserve">
    <value>該当する集計メソッド '{0}({1})' が存在しません</value>
  </data>
  <data name="NoApplicableIndexer" xml:space="preserve">
    <value>型 '{0}' に適切なインデクサーが存在します。</value>
  </data>
  <data name="NoApplicableMethod" xml:space="preserve">
    <value>型 '{1}' に適用可能なメソッド '{0}' が存在します。</value>
  </data>
  <data name="NoItInScope" xml:space="preserve">
    <value>いいえ '' スコープ内にあります。</value>
  </data>
  <data name="NoMatchingConstructor" xml:space="preserve">
    <value>型 '{0}' に一致するコンス トラクターはありません。</value>
  </data>
  <data name="NoParentInScope" xml:space="preserve">
    <value>スコープではない '親'</value>
  </data>
  <data name="NoRootInScope" xml:space="preserve">
    <value>スコープに含まれる 'ルート' がありません。</value>
  </data>
  <data name="OpenBracketExpected" xml:space="preserve">
    <value>' [' と予想</value>
  </data>
  <data name="OpenParenExpected" xml:space="preserve">
    <value>'(' expected</value>
  </data>
  <data name="OpenParenOrIdentifierExpected" xml:space="preserve">
    <value>' (' または識別子が必要</value>
  </data>
  <data name="ParseExceptionFormat" xml:space="preserve">
    <value>(でインデックス {1}) {0}</value>
  </data>
  <data name="SyntaxError" xml:space="preserve">
    <value>構文エラー</value>
  </data>
  <data name="TokenExpected" xml:space="preserve">
    <value>{0} の期待</value>
  </data>
  <data name="TypeHasNoNullableForm" xml:space="preserve">
    <value>型 '{0}' は null 許容フォーム</value>
  </data>
  <data name="UnknownIdentifier" xml:space="preserve">
    <value>不明な識別子 ' {0} '</value>
  </data>
  <data name="UnknownPropertyOrField" xml:space="preserve">
    <value>プロパティまたはフィールド '{0}' がない型 '{1}' で</value>
  </data>
  <data name="UnterminatedStringLiteral" xml:space="preserve">
    <value>文字列リテラルが損なわれています</value>
  </data>
  <data name="CloseBracketExpected" xml:space="preserve">
    <value>']'が必要です</value>
  </data>
  <data name="DotExpected" xml:space="preserve">
    <value>「。」 期待される</value>
  </data>
  <data name="DotOrOpenParenOrStringLiteralExpected" xml:space="preserve">
    <value>「。」 または '（'または文字列リテラルが必要です</value>
  </data>
  <data name="FunctionRequiresOneArg" xml:space="preserve">
    <value>'{0}'関数には1つの引数が必要です</value>
  </data>
  <data name="FunctionRequiresOneNotNullArg" xml:space="preserve">
    <value>'{0}'関数には、nullではない引数が1つ必要です。</value>
  </data>
  <data name="HexCharExpected" xml:space="preserve">
    <value>16進文字が必要です</value>
  </data>
  <data name="IncompatibleTypes" xml:space="preserve">
    <value>タイプ '{0}'と '{1}'は互換性がありません</value>
  </data>
  <data name="InvalidIntegerQualifier" xml:space="preserve">
    <value>無効な整数リテラル修飾子 '{0}'</value>
  </data>
  <data name="IQueryableProviderNotAsync" xml:space="preserve">
    <value>ソースIQueryableのプロバイダーは、IAsyncQueryProvider / IDbAsyncQueryProviderを実装していません。 IAsyncQueryProvider / IDbAsyncQueryProviderを実装するプロバイダーのみが、Entity Frameworkの非同期操作に使用できます。</value>
  </data>
  <data name="IsNullRequiresTwoArgs" xml:space="preserve">
    <value>'isnull'関数には2つの引数が必要です</value>
  </data>
  <data name="MinusCannotBeAppliedToUnsignedInteger" xml:space="preserve">
    <value>「-」は符号なし整数には適用できません。</value>
  </data>
  <data name="NullPropagationRequiresCorrectArgs" xml:space="preserve">
    <value>'np'（null-propagation）関数には1つまたは2つの引数が必要です</value>
  </data>
  <data name="OpenCurlyParenExpected" xml:space="preserve">
    <value>「{」が必要です</value>
  </data>
  <data name="TypeNotFound" xml:space="preserve">
    <value>タイプ '{0}'が見つかりません</value>
  </data>
  <data name="OutKeywordRequiresDiscard" xml:space="preserve">
    <value>out 変数を使用する場合は、破棄 '_' が必要です。</value>
  </data>
  <data name="NewOperatorIsNotAllowed" xml:space="preserve">
    <value>ParsingConfig では new 演算子の使用は許可されていません。</value>
  </data>
  <data name="NullPropagationRequiresValidExpression" xml:space="preserve">
    <value>'np' (null-propagation) 関数では、最初の引数が MemberExpression、ParameterExpression、または MethodCallExpression である必要があります。</value>
  </data>
  <data name="FunctionRequiresOneOrTwoArgs" xml:space="preserve">
    <value>'{0}' 関数には 1 つまたは 2 つの引数が必要です</value>
  </data>
  <data name="EnumTypeNotFound" xml:space="preserve">
    <value>列挙型 '{0}' が見つかりません</value>
  </data>
  <data name="EnumValueExpected" xml:space="preserve">
    <value>期待される列挙値</value>
  </data>
  <data name="EnumValueNotDefined" xml:space="preserve">
    <value>列挙値 '{0}' は列挙型 '{1}' で定義されていません</value>
  </data>
  <data name="FunctionRequiresNotNullArgOfType" xml:space="preserve">
    <value>'{0}' 関数では、{1} 引数が null ではなく、型が {2} である必要があります。</value>
  </data>
  <data name="BinaryCharExpected" xml:space="preserve">
    <value>バイナリ文字が必要です</value>
  </data>
  <data name="DynamicExpandoObjectIsNotSupported" xml:space="preserve">
    <value>Dynamic / ExpandoObject は .NET 3.5、UAP、および .NETStandard 1.3 ではサポートされていません</value>
  </data>
  <data name="InvalidBinaryIntegerLiteral" xml:space="preserve">
    <value>無効な 2 進整数リテラル '{0}'</value>
  </data>
  <data name="InvalidStringLength" xml:space="preserve">
    <value>文字列 '{0}' には少なくとも {1} 文字が必要です。</value>
  </data>
  <data name="InvalidStringQuoteCharacter" xml:space="preserve">
    <value>エスケープ文字列は二重引用符 (\") または単一引用符 (') で始まる必要があります。</value>
  </data>
  <data name="UnexpectedUnclosedString" xml:space="preserve">
    <value>'{1}' 付近の位置 {0} に、閉じられていない文字列を持つ文字列の予期しない終端があります。</value>
  </data>
  <data name="UnexpectedUnrecognizedEscapeSequence" xml:space="preserve">
    <value>'{1}' 付近の位置 {0} に予期しない認識されないエスケープ シーケンスがあります。</value>
  </data>
</root>